/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.16.5.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/
import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Uint128, Coin, BlacklisteesResponse, BlacklisterAllowancesResponse, AllowanceResponse, AllowancesResponse, DenomResponse, FreezerAllowancesResponse, StatusResponse, IsFrozenResponse, OwnerResponse } from "./TokenfactoryIssuer.types";
export interface TokenfactoryIssuerReadOnlyInterface {
    contractAddress: string;
    isFrozen: () => Promise<IsFrozenResponse>;
    denom: () => Promise<DenomResponse>;
    owner: () => Promise<OwnerResponse>;
    burnAllowance: ({ address }: {
        address: string;
    }) => Promise<AllowanceResponse>;
    burnAllowances: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<AllowancesResponse>;
    mintAllowance: ({ address }: {
        address: string;
    }) => Promise<AllowanceResponse>;
    mintAllowances: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<AllowancesResponse>;
    isBlacklisted: ({ address }: {
        address: string;
    }) => Promise<StatusResponse>;
    blacklistees: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<BlacklisteesResponse>;
    isBlacklister: ({ address }: {
        address: string;
    }) => Promise<StatusResponse>;
    blacklisterAllowances: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<BlacklisterAllowancesResponse>;
    isFreezer: ({ address }: {
        address: string;
    }) => Promise<StatusResponse>;
    freezerAllowances: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<FreezerAllowancesResponse>;
}
export declare class TokenfactoryIssuerQueryClient implements TokenfactoryIssuerReadOnlyInterface {
    client: CosmWasmClient;
    contractAddress: string;
    constructor(client: CosmWasmClient, contractAddress: string);
    isFrozen: () => Promise<IsFrozenResponse>;
    denom: () => Promise<DenomResponse>;
    owner: () => Promise<OwnerResponse>;
    burnAllowance: ({ address }: {
        address: string;
    }) => Promise<AllowanceResponse>;
    burnAllowances: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<AllowancesResponse>;
    mintAllowance: ({ address }: {
        address: string;
    }) => Promise<AllowanceResponse>;
    mintAllowances: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<AllowancesResponse>;
    isBlacklisted: ({ address }: {
        address: string;
    }) => Promise<StatusResponse>;
    blacklistees: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<BlacklisteesResponse>;
    isBlacklister: ({ address }: {
        address: string;
    }) => Promise<StatusResponse>;
    blacklisterAllowances: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<BlacklisterAllowancesResponse>;
    isFreezer: ({ address }: {
        address: string;
    }) => Promise<StatusResponse>;
    freezerAllowances: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<FreezerAllowancesResponse>;
}
export interface TokenfactoryIssuerInterface extends TokenfactoryIssuerReadOnlyInterface {
    contractAddress: string;
    sender: string;
    changeTokenFactoryAdmin: ({ newAdmin }: {
        newAdmin: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    changeContractOwner: ({ newOwner }: {
        newOwner: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    setMinter: ({ address, allowance }: {
        address: string;
        allowance: Uint128;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    setBurner: ({ address, allowance }: {
        address: string;
        allowance: Uint128;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    setBlacklister: ({ address, status }: {
        address: string;
        status: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    setFreezer: ({ address, status }: {
        address: string;
        status: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    mint: ({ amount, toAddress }: {
        amount: Uint128;
        toAddress: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    burn: ({ amount, fromAddress }: {
        amount: Uint128;
        fromAddress: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    blacklist: ({ address, status }: {
        address: string;
        status: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    freeze: ({ status }: {
        status: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export declare class TokenfactoryIssuerClient extends TokenfactoryIssuerQueryClient implements TokenfactoryIssuerInterface {
    client: SigningCosmWasmClient;
    sender: string;
    contractAddress: string;
    constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string);
    changeTokenFactoryAdmin: ({ newAdmin }: {
        newAdmin: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    changeContractOwner: ({ newOwner }: {
        newOwner: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    setMinter: ({ address, allowance }: {
        address: string;
        allowance: Uint128;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    setBurner: ({ address, allowance }: {
        address: string;
        allowance: Uint128;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    setBlacklister: ({ address, status }: {
        address: string;
        status: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    setFreezer: ({ address, status }: {
        address: string;
        status: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    mint: ({ amount, toAddress }: {
        amount: Uint128;
        toAddress: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    burn: ({ amount, fromAddress }: {
        amount: Uint128;
        fromAddress: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    blacklist: ({ address, status }: {
        address: string;
        status: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    freeze: ({ status }: {
        status: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
//# sourceMappingURL=TokenfactoryIssuer.client.d.ts.map