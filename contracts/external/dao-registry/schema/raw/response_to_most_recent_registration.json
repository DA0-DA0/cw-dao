{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Nullable_Registration",
  "anyOf": [
    {
      "$ref": "#/definitions/Registration"
    },
    {
      "type": "null"
    }
  ],
  "definitions": {
    "Addr": {
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    },
    "CheckedDenom": {
      "description": "A denom that has been checked to point to a valid asset. This enum should never be constructed literally and should always be built by calling `into_checked` on an `UncheckedDenom` instance.",
      "oneOf": [
        {
          "description": "A native (bank module) asset.",
          "type": "object",
          "required": [
            "native"
          ],
          "properties": {
            "native": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "A cw20 asset.",
          "type": "object",
          "required": [
            "cw20"
          ],
          "properties": {
            "cw20": {
              "$ref": "#/definitions/Addr"
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "Config": {
      "type": "object",
      "required": [
        "fee_amount",
        "fee_denom",
        "registration_period"
      ],
      "properties": {
        "fee_amount": {
          "description": "The fee amount to register a DAO.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "fee_denom": {
          "description": "The fee denom to register a DAO.",
          "allOf": [
            {
              "$ref": "#/definitions/CheckedDenom"
            }
          ]
        },
        "registration_period": {
          "description": "How long a registration lasts. For a new registration, this is the first expiration. For a renewal, this is the amount of time added to the current expiration.",
          "allOf": [
            {
              "$ref": "#/definitions/Timestamp"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Registration": {
      "type": "object",
      "required": [
        "address",
        "expiration",
        "name",
        "status"
      ],
      "properties": {
        "address": {
          "description": "The address of the DAO.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "expiration": {
          "description": "When the registration expires.",
          "allOf": [
            {
              "$ref": "#/definitions/Timestamp"
            }
          ]
        },
        "name": {
          "description": "The unique name of the DAO.",
          "type": "string"
        },
        "status": {
          "description": "The status of the registration.",
          "allOf": [
            {
              "$ref": "#/definitions/RegistrationStatus"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "RegistrationStatus": {
      "oneOf": [
        {
          "description": "The registration is pending approval.",
          "type": "object",
          "required": [
            "pending"
          ],
          "properties": {
            "pending": {
              "type": "object",
              "required": [
                "config"
              ],
              "properties": {
                "config": {
                  "description": "The config that was used to register. This is necessary in case the fee or registration period change after a request is submitted.",
                  "allOf": [
                    {
                      "$ref": "#/definitions/Config"
                    }
                  ]
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "description": "The registration was approved.",
          "type": "string",
          "enum": [
            "approved"
          ]
        },
        {
          "description": "The registration is rejected.",
          "type": "string",
          "enum": [
            "rejected"
          ]
        },
        {
          "description": "The registration is revoked.",
          "type": "string",
          "enum": [
            "revoked"
          ]
        }
      ]
    },
    "Timestamp": {
      "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
      "allOf": [
        {
          "$ref": "#/definitions/Uint64"
        }
      ]
    },
    "Uint128": {
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "Uint64": {
      "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
      "type": "string"
    }
  }
}
